<!DOCTYPE html>
<html>
<head>
    

    

    



    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    
    
    
    <title>IO路径流向初探 | 行路中. | 脚踏实地</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="linux,IO,存储">
    <meta name="description" content="todo ceph-fuse是如何将系统调用注册成自己的程序的呢?  libcephfs 是ceph-fuse通信的内核模块 ceph-fuse来处理真实的逻辑 本文提到为了系统实现概念的统一性、设计的一致性以及层次抽象与共用，操作系统将iscsi协议对接到scsi中间层。这种实现对性能的损失有多大？如果我们在device-mapper之下实现又会怎么样 https://www.kernel.or">
<meta name="keywords" content="linux,IO,存储">
<meta property="og:type" content="article">
<meta property="og:title" content="IO路径流向初探">
<meta property="og:url" content="https://sean10.github.io/2021/09/08/IO路径流向初探/index.html">
<meta property="og:site_name" content="行路中.">
<meta property="og:description" content="todo ceph-fuse是如何将系统调用注册成自己的程序的呢?  libcephfs 是ceph-fuse通信的内核模块 ceph-fuse来处理真实的逻辑 本文提到为了系统实现概念的统一性、设计的一致性以及层次抽象与共用，操作系统将iscsi协议对接到scsi中间层。这种实现对性能的损失有多大？如果我们在device-mapper之下实现又会怎么样 https://www.kernel.or">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-10-21-08.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-26-18.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-12-39-32.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-13-00-05-05.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-00-58-04.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-00-59-01.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-01-11-50.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-04-20-26-59.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-04-22-04-15.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-04-23-32-24.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-00-50-33.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-10-24-41.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-15-52.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-18-39.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-21-55.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-40-56.png">
<meta property="og:image" content="https://www.thomas-krenn.com/de/wikiDE/images/7/72/Linux-storage-stack-diagram_v4.10.svg">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-19-57.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-22-23.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-10-40-32.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-10-41-04.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-16-32.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-13-00-06-03.png">
<meta property="og:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-13-00-06-42.png">
<meta property="og:updated_time" content="2021-09-27T10:10:09.999Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IO路径流向初探">
<meta name="twitter:description" content="todo ceph-fuse是如何将系统调用注册成自己的程序的呢?  libcephfs 是ceph-fuse通信的内核模块 ceph-fuse来处理真实的逻辑 本文提到为了系统实现概念的统一性、设计的一致性以及层次抽象与共用，操作系统将iscsi协议对接到scsi中间层。这种实现对性能的损失有多大？如果我们在device-mapper之下实现又会怎么样 https://www.kernel.or">
<meta name="twitter:image" content="https://sean10.github.io/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-10-21-08.png">
    
        <link rel="alternate" type="application/atom+xml" title="行路中." href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.png">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Sean10</h5>
          <a href="mailto:sean10reborn@gmail.com" title="sean10reborn@gmail.com" class="mail">sean10reborn@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/sean10" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">IO路径流向初探</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">IO路径流向初探</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-09-08T03:59:38.000Z" itemprop="datePublished" class="page-time">
  2021-09-08
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/pro/">专业</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#todo"><span class="post-toc-number">1.</span> <span class="post-toc-text">todo</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#faq"><span class="post-toc-number"></span> <span class="post-toc-text">FAQ</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#网络协议栈"><span class="post-toc-number"></span> <span class="post-toc-text">网络协议栈</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#分布式io路径"><span class="post-toc-number"></span> <span class="post-toc-text">分布式IO路径</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#存储协议-io路径"><span class="post-toc-number"></span> <span class="post-toc-text">存储协议 IO路径</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#iscsi"><span class="post-toc-number"></span> <span class="post-toc-text">iSCSi</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#对于k8s-openstack对接的存储路径"><span class="post-toc-number"></span> <span class="post-toc-text">对于K8S,
openstack对接的存储路径</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#工具"><span class="post-toc-number"></span> <span class="post-toc-text">工具</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#blocktrace"><span class="post-toc-number"></span> <span class="post-toc-text">blocktrace</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#iowatcher"><span class="post-toc-number"></span> <span class="post-toc-text">iowatcher</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#文件系统io路径"><span class="post-toc-number"></span> <span class="post-toc-text">文件系统IO路径</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#操作系统路径"><span class="post-toc-number"></span> <span class="post-toc-text">操作系统路径</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#vfs-layer"><span class="post-toc-number"></span> <span class="post-toc-text">VFS Layer</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文件系统驱动层"><span class="post-toc-number"></span> <span class="post-toc-text">文件系统驱动层</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#nfs"><span class="post-toc-number">1.</span> <span class="post-toc-text">NFS</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ext2"><span class="post-toc-number">2.</span> <span class="post-toc-text">Ext2</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ext3"><span class="post-toc-number">3.</span> <span class="post-toc-text">Ext3</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ext4"><span class="post-toc-number">4.</span> <span class="post-toc-text">Ext4</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#cephfs-内核"><span class="post-toc-number">5.</span> <span class="post-toc-text">cephfs (内核)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ntfs"><span class="post-toc-number">6.</span> <span class="post-toc-text">NTFS</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#page-cache-layer"><span class="post-toc-number"></span> <span class="post-toc-text">Page Cache Layer</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#查看内存中脏数据"><span class="post-toc-number">1.</span> <span class="post-toc-text">查看内存中脏数据</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#generic-block-layer"><span class="post-toc-number"></span> <span class="post-toc-text">Generic Block Layer</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#device-mapper-layer15"><span class="post-toc-number"></span> <span class="post-toc-text">Device Mapper Layer[^15]</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#io-scheduler-layer"><span class="post-toc-number"></span> <span class="post-toc-text">I/O Scheduler Layer</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#block-device-driver-layer"><span class="post-toc-number"></span> <span class="post-toc-text">Block Device Driver Layer</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#block-device-layer"><span class="post-toc-number"></span> <span class="post-toc-text">Block Device Layer</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#块对象的io路径."><span class="post-toc-number"></span> <span class="post-toc-text">块对象的IO路径.</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#读路径"><span class="post-toc-number"></span> <span class="post-toc-text">读路径</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#应用态业务程序"><span class="post-toc-number">1.</span> <span class="post-toc-text">应用态业务程序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#应用态程序缓存-命中则提高"><span class="post-toc-number">2.</span> <span class="post-toc-text">应用态程序缓存, 命中则提高</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件系统层"><span class="post-toc-number">3.</span> <span class="post-toc-text">文件系统层</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内核态缓存-命中则提高-page-cache"><span class="post-toc-number">4.</span> <span class="post-toc-text">内核态缓存, 命中则提高 page
cache?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#通用块层"><span class="post-toc-number">5.</span> <span class="post-toc-text">通用块层</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内核态到块设备之间的驱动-包含缓存"><span class="post-toc-number">6.</span> <span class="post-toc-text">内核态到块设备之间的驱动,
包含缓存?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分层缓存设备"><span class="post-toc-number">7.</span> <span class="post-toc-text">分层缓存设备</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#元数据分离-通过高速硬件提高元数据读取性能"><span class="post-toc-number">8.</span> <span class="post-toc-text">元数据分离,
通过高速硬件提高元数据读取性能</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#根据元数据指定的地址-在低速设备上查询真实速度"><span class="post-toc-number">9.</span> <span class="post-toc-text">根据元数据指定的地址,
在低速设备上查询真实速度</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#硬盘预读能力-如果命中了提高性能"><span class="post-toc-number">10.</span> <span class="post-toc-text">硬盘预读能力,
如果命中了提高性能</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#写路径"><span class="post-toc-number"></span> <span class="post-toc-text">写路径</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#应用态业务程序-1"><span class="post-toc-number">1.</span> <span class="post-toc-text">应用态业务程序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#应用态程序缓存-io聚合-随机io转顺序-或缓存命中直接返回-存在一致性风险"><span class="post-toc-number">2.</span> <span class="post-toc-text">应用态程序缓存,
IO聚合, 随机IO转顺序, 或缓存命中直接返回, 存在一致性风险</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内核态缓-存-io聚合-或缓存命中直接返回-存在一致性风险"><span class="post-toc-number">3.</span> <span class="post-toc-text">内核态缓
存, IO聚合, 或缓存命中直接返回, 存在一致性风险</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内核态到块设备-驱动层面聚合"><span class="post-toc-number">4.</span> <span class="post-toc-text">内核态到块设备, 驱动层面聚合</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分层缓存设备-写命中的对象-则可以直接返回-免去访问更底层的"><span class="post-toc-number">5.</span> <span class="post-toc-text">分层缓存设备,
写命中的对象, 则可以直接返回, 免去访问更底层的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#元数据分离-如果是小io-直接落元数据分区所在的高速设备-如果是低速-则继续下传"><span class="post-toc-number">6.</span> <span class="post-toc-text">元数据分离,
如果是小io, 直接落元数据分区所在的高速设备, 如果是低速, 则继续下传</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#硬盘随机写能力-看硬盘的算法-是否有缓存进行io聚合之类的."><span class="post-toc-number">7.</span> <span class="post-toc-text">硬盘随机写能力,
看硬盘的算法, 是否有缓存进行IO聚合之类的.</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#基于io路径的优化"><span class="post-toc-number"></span> <span class="post-toc-text">基于IO路径的优化</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#异步aio"><span class="post-toc-number"></span> <span class="post-toc-text">异步aio</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#预读"><span class="post-toc-number"></span> <span class="post-toc-text">预读</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#内存参数"><span class="post-toc-number"></span> <span class="post-toc-text">内存参数</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#前沿趋势"><span class="post-toc-number"></span> <span class="post-toc-text">前沿趋势</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#调试排查29"><span class="post-toc-number"></span> <span class="post-toc-text">调试排查[^29]</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#reference"><span class="post-toc-number"></span> <span class="post-toc-text">Reference</span></a>
        </nav>
    </aside>


<article id="post-IO路径流向初探"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">IO路径流向初探</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-09-08 11:59:38" datetime="2021-09-08T03:59:38.000Z"  itemprop="datePublished">2021-09-08</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/pro/">专业</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="todo">todo</h3>
<p>ceph-fuse是如何将系统调用注册成自己的程序的呢?</p>
<ul>
<li><p>libcephfs 是ceph-fuse通信的内核模块</p></li>
<li><p>ceph-fuse来处理真实的逻辑</p></li>
<li><p>本文提到为了系统实现概念的统一性、设计的一致性以及层次抽象与共用，操作系统将iscsi协议对接到scsi中间层。这种实现对性能的损失有多大？如果我们在device-mapper之下实现又会怎么样</p></li>
<li><p>https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/cache-policies.html</p>
<ul>
<li>kernel的文档</li>
</ul></li>
<li><p>磁盘Cache 是否是在硬盘驱动哪层</p></li>
<li><p>avgrq-sz这个东西应该有个上限, 好像是512K</p>
<ul>
<li><a href="https://martincarstenbach.wordpress.com/2013/07/03/increasing-the-maximum-io-size-in-linux/" target="_blank" rel="noopener">Increasing
the maximum I/O size in Linux | Martins Blog</a></li>
<li><blockquote>
<p>The default maximum IO size set by Max_Sectors_KB restricts the
largest IO size that the OS will issue to a block device.</p>
</blockquote></li>
<li><blockquote>
<p>Whether you will be issuing IO at this size will depend on the
elevator (scheduler) being used, the driver, and the type of IO your
applications are issuing. But large reads and writes are often at the
maximum IO size.</p>
</blockquote></li>
<li><blockquote>
<p>The answer is to use UDEV.</p>
</blockquote></li>
<li>All you need to do is create a file “71-block-max-sectors.rules”
under /etc/udev/rules.d/ with the following line.</li>
<li><blockquote>
<p>ACTION==”add|change”, SUBSYSTEM==”block”, RUN+=”/bin/sh -c ‘/bin/echo
1024 &gt; /sys%p/queue/max_sectors_kb’”[^18]</p>
</blockquote></li>
<li>– max_sectors_kb</li>
<li>– max_hw_sectors_kb</li>
</ul></li>
<li><p>这个内核的队列到底有多大. 队列大小.</p></li>
<li><p>autocork</p></li>
</ul>
<h1 id="faq">FAQ</h1>
<ol type="1">
<li><p>write返回成功数据落盘了吗？ &gt; Buffered
IO：write返回数据仅仅是写入了PageCache，还没有落盘。 &gt; &gt; Direct
IO：write返回数据仅仅是到了通用块层放入IO队列，依旧没有落盘。 &gt; &gt;
此时设备断电、宕机仍然会发生数据丢失。需要调用fsync或者fdatasync把数据刷到磁盘上，调用命令时，磁盘本身缓存(DiskCache)的内容也会持久化到磁盘上。
&gt; 2、write系统调用是原子的吗？ &gt;
write系统调用不是原子的，如果有多线程同时调用，数据可能会发生错乱。可以使用O_APPEND标志打开文件，只能追加写，这样多线程写入就不会发生数据错乱。
&gt; 3、mmap相比read、write快在了哪里？ &gt;
mmap直接把PageCache映射到用户态，少了一次系统调用，也少了一次数据在用户态和内核态的拷贝。
&gt; &gt; mmap通常和read搭配使用：写入使用write+sync，读取使用mmap。
&gt; 4、为什么Direct IO需要数据对齐？ &gt;
DIO跳过了PageCache，直接到通用块层，而通用块层的IO都必须是块大小对齐的，所以需要用户程序自行对齐offset、length。
&gt; 5、Libaio的IO栈？ &gt;
write()—&gt;sys_write()—&gt;vfs_write()—&gt;通用块层—&gt;IO调度层—&gt;块设备驱动层—&gt;块设备
6、为什么需要 by pass pagecache？ &gt;
当应用程序不满Linux内核的Cache策略，有更适合自己的Cache策略时可以使用Direct
IO跳过PageCache。例如Mysql。 &gt;</p></li>
<li><p>为什么需要 by pass kernel？ &gt;
当应用程序对延迟极度敏感时，由于Linux内核IO栈有7层，IO路径比较长，为了缩短IO路径，降低IO延迟，可以by
pass
kernel，直接使用用户态的块设备驱动程序。例如spdk的nvme，阿里云的ESSD。
&gt;</p></li>
<li><p>为什么需要直接操作裸设备？ &gt;
当应用程序仅仅使用了基本的read、write，用不到文件系统的大而全的功能，此时文件系统的开销对于应用程序来说是一种累赘，此时需要跳过文件系统，接管裸设备，自己实现磁盘分配、缓存等功能，通常使用DIO+Libaio+裸设备。例如Ceph
FileStore的Journal、Ceph BlueStore。</p></li>
<li><p>mmap和direct IO区别 &gt; &gt;
系统调用，write会触发用户态/内核态切换？是的。那有没有办法避免这些消耗。这时候该mmap出场了，mmap把page
cache
地址空间映射到用户空间，应用程序像操作应用层内存一样，写文件。省去了系统调用开销。
&gt; &gt; 那如果继续刨根问底，如果想绕过page
cache，直接把数据送到磁盘设备上怎么办。通过open文件带上O_DIRECT参数，这是write该文件。就是直接写到设备上。
&gt; &gt;<br>
&gt; &gt;
如果继续较劲，直接写扇区有没有办法。这就是所谓的RAW设备写，绕开了文件系统，直接写扇区，想fdsik，dd，cpio之类的工具就是这一类操作。</p></li>
<li><p>LIO</p></li>
</ol>
<blockquote>
<p>Linux-IO Target在Linux内核中（linux 2.6.38后），用软件实现各种SCSI
Target，其支持的SAN技术中所有流行的存储协议包括Fibre
Channel（Qlogic，linux3.5）、FCoE（linux3.0）、iSCSI（linux 3.1）、iSER
(Mellanox InfiniBand，linux3.10), SRP (Mellanox InfiniBand，linux3.3),
USB等，同时还能为本机生成模拟的SCSI设备，以及为虚拟机提供基于virtio的SCSI设备。Linux-IO
Target使用户能够使用相对廉价的Linux系统实现SCSI、SAN的各种功能，而不用购买昂贵的专业设备。</p>
</blockquote>
<ol start="11" type="1">
<li>TCMU+librbd 用户态方案?</li>
</ol>
<p>TCM targets 运行在内核态，TCMU（TCM in Userspace）是LIO
的用户态实现。</p>
<h1 id="网络协议栈">网络协议栈</h1>
<blockquote>
<p>传统的网络层数据传输协议栈：</p>
<p>　　内核层：硬件中断—&gt;取包分发至内核线程—&gt;软件中断—&gt;内核线程在协议栈中处理包—&gt;处理完毕通知用户层</p>
<p>　　用户层：收包–&gt;网络层—&gt;逻辑层—&gt;业务层</p>
</blockquote>
<h1 id="分布式io路径">分布式IO路径</h1>
<h1 id="存储协议-io路径">存储协议 IO路径</h1>
<blockquote>
<p>存储的接入模块包括协议层接入、Client 模块。协议层就是上面所说的
iSCSI、NFS 等协议，而 Client
模块则负责将上层请求转换成存储系统所能支持的读写请求发送到存储的核心 IO
模块，这些要做的以及可以做东西很多：故障域管理、IO 转发、IO 超时重试、IO
条带化、集群节点视图等，每一个点都很有搞头。接入模块的改造潜力是比较大的，如利用
SPDK 改造 vhost / iSCSI .</p>
</blockquote>
<p>这里其实指的就是iSCSI的Target端与下层存储服务的对接了把</p>
<blockquote>
<p>主节点负责管理元数据和 IO
调度，从节点则负责读写数据，乖乖的干活即可。在没有主从之分的 peer
存储系统中，可管理元数据并不多，并且多集中在接入模块的 Client
中，因为它的元数据多是计算出来的，而集中式存储系统多是查出来的，所以存储系统按照这种方式可以分为计算型和查表型。集中式存储系统的元数据多存于类似
LevelDB 或 RocksDB 的单机存储引擎中。</p>
</blockquote>
<h2 id="iscsi">iSCSi</h2>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-10-21-08.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-26-18.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-12-39-32.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-13-00-05-05.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="对于k8s-openstack对接的存储路径">对于K8S,
openstack对接的存储路径</h2>
<blockquote>
<p>常见的 CSI 对接有块存储的 iSCSI、对象存储的
FUSE，还有一些其他比较小众的，比如 ceph 的 rbd、sheepdog 的 sbd
等，这些的原理就是通过注册内核相关的 block device 类型来做的。</p>
</blockquote>
<p><a href="https://runsisi.com/2018-12-26/ceph-iscsi-research" target="_blank" rel="noopener">https://runsisi.com/2018-12-26/ceph-iscsi-research</a></p>
<h1 id="工具">工具</h1>
<h2 id="blocktrace">blocktrace</h2>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-00-58-04.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>第一个字段：8,0 这个字段是设备号 major device ID和minor device ID。
第二个字段：3 表示CPU 第三个字段：11 序列号 第四个字段：0.009507758 Time
Stamp是时间偏移 第五个字段：PID 本次IO对应的进程ID
第六个字段：Event，这个字段非常重要，反映了IO进行到了那一步
第七个字段：R表示 Read， W是Write，D表示block，B表示Barrier Operation
第八个字段：223490+56，表示的是起始block number 和 number of
blocks，即我们常说的Offset 和 Size 第九个字段： 进程名</p>
<p>其中第六个字段非常有用：每一个字母都代表了IO请求所经历的某个阶段。</p>
</blockquote>
<blockquote>
<p>Q – 即将生成IO请求 | G – IO请求生成 | I – IO请求进入IO Scheduler队列
| D – IO请求进入driver | C – IO请求执行完毕</p>
</blockquote>
<h2 id="iowatcher">iowatcher</h2>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-00-59-01.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h1 id="文件系统io路径">文件系统IO路径</h1>
<h2 id="操作系统路径">操作系统路径</h2>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-01-11-50.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-04-20-26-59.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-04-22-04-15.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-04-23-32-24.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-00-50-33.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-10-24-41.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-15-52.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>当用户调用了write、read等系统调用陷入内核之后，系统会首先针对关联的file对象找到对应的file
system，此处针对后端是否有持久化存储可将众多的file
system划分为两类，在此我们关心的是后端对应真实存储的file
system，经过了file
system层处理之后将所有的数据块划分为了一个个的bio，交给device
mapper层处理，device
mapper层主要完成逻辑设备到物理设备的映射工作，例如可以将bio按LBA地址分别映射到管理的多个设备上(linear，raid0)，将bio映射到每个设备上（mirror,
raid1），或者是提供快照和多路径的功能，再往下是具体的block层，此处会为每个设备提供一个queue，在queue之上使用各种io
scheduler(noop/deadline/cfq)进行请求的合并，最后调用各种不同的设备驱动完成服务。SCSI子模块就是这众多驱动中的一种，其他的还有按照协议和总线划分还有USB，ATA等等。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-18-39.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-21-55.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-40-56.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://www.thomas-krenn.com/de/wikiDE/images/7/72/Linux-storage-stack-diagram_v4.10.svg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="vfs-layer">VFS Layer</h2>
<p>系统调用文件系统的函数, 参数为文件描述符和文件偏移量.</p>
<p>VFS支持的文件系统主要有三种类型：</p>
<p>基于磁盘的文件系统：Ext系列、XFS等。 网络文件系统：NFS、CIFS等。
特殊文件系统：/proc、裸设备等。
VFS主要有四个对象类型(不同的文件系统都要实现)：</p>
<p>superblock：整个文件系统的元信息。对应的操作结构体：struct
super_operations。 inode：单个文件的元信息。对应的操作结构体：struct
inode_operations。
dentry：目录项，一个文件目录对应一个dentry。对应的操作结构体：struct
dentry_operations。 file：进程打开的一个文件。对应的操作结构体：struct
file_operations</p>
<h2 id="文件系统驱动层">文件系统驱动层</h2>
<p>具体的文件系统实现</p>
<blockquote>
<p>物理页与扇区的对应关系由文件系统定义，文件系统定义了一个内存页(4KB)与多少个块对应，对应关系在格式化磁盘时设定，运行时由buffer_head保存对应关系：[^23]</p>
<p>linux # cat /proc/slabinfo | grep buffer_head buffer_head 12253 12284
104 37 1 : tunables 120 60 8 : slabdata 332 332 0</p>
</blockquote>
<h3 id="nfs">NFS</h3>
<h3 id="ext2">Ext2</h3>
<h3 id="ext3">Ext3</h3>
<h3 id="ext4">Ext4</h3>
<h3 id="cephfs-内核">cephfs (内核)</h3>
<h3 id="ntfs">NTFS</h3>
<h2 id="page-cache-layer">Page Cache Layer</h2>
<blockquote>
<p>Cache层在内存中缓存了磁盘上的部分数据。</p>
</blockquote>
<blockquote>
<p>Page
Cache主要用来作为文件系统上的文件数据的缓存来用，尤其是针对当进程对文件有read/write操作的时候。</p>
</blockquote>
<blockquote>
<p>在Linux的实现中，文件Cache分为两个层面，一是Page Cache，另一个Buffer
Cache，每一个Page Cache包含若干Buffer Cache。Page
Cache主要用来作为文件系统上的文件数据的缓存来用，尤其是针对当进程对文件有read/write操作的时候。Buffer
Cache则主要是设计用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用。</p>
</blockquote>
<p>磁盘Cache有两大功能：预读和回写。预读其实就是利用了局部性原理，具体过程是：对于每个文件的第一个读请求，系统读入所请求的页面并读入紧随其后的少数几个页面（通常是三个页面），这时的预读称为同步预读。对于第二次读请求，如果所读页面不在Cache中，即不在前次预读的页中，则表明文件访问不是顺序访问，系统继续采用同步预读；如果所读页面在Cache中，则表明前次预读命中，操作系统把预读页的大小扩大一倍，此时预读过程是异步的，应用程序可以不等预读完成即可返回，只要后台慢慢读页面即可，这时的预读称为异步预读。任何接下来的读请求都会处于两种情况之一：第一种情况是所请求的页面处于预读的页面中，这时继续进行异步预读；第二种情况是所请求的页面处于预读页面之外，这时系统就要进行同步预读。</p>
<p>回写是通过暂时将数据存在Cache里，然后统一异步写到磁盘中。通过这种异步的数据I/O模式解决了程序中的计算速度和数据存储速度不匹配的鸿沟，减少了访问底层存储介质的次数，使存储系统的性能大大提高。Linux
2.6.32内核之前，采用pdflush机制来将脏页真正写到磁盘中，</p>
<p>Linux
2.6.32内核之后，放弃了原有的pdflush机制，改成了bdi_writeback机制。bdi_writeback机制主要解决了原有fdflush机制存在的一个问题：在多磁盘的系统中，pdflush管理了所有磁盘的Cache，从而导致一定程度的I/O瓶颈。bdi_writeback机制为每个磁盘都创建了一个线程，专门负责这个磁盘的Page
Cache的刷新工作，从而实现了每个磁盘的数据刷新在线程级的分离，提高了I/O性能。</p>
<p>回写机制存在的问题是回写不及时引发数据丢失（可由sync|fsync解决），回写期间读I/O性能很差。
### 参数 sysctl -a | grep dirty &gt; ls -l /proc/sys/vm/dirty_*</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -l /proc/sys/vm/dirty_*</span></span><br><span class="line"><span class="comment"># 内存可以填充数据的字节数</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 15 22:05 /proc/sys/vm/dirty_background_bytes</span><br><span class="line"><span class="comment"># 内存可以填充脏数据的百分比</span></span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root 0 Sep 26 07:59 /proc/sys/vm/dirty_background_ratio</span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 15 22:05 /proc/sys/vm/dirty_bytes</span><br><span class="line"><span class="comment"># 指定仓数据能够存活的时间</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 15 22:05 /proc/sys/vm/dirty_expire_centisecs</span><br><span class="line"><span class="comment"># 可以用脏数据填充的绝对最大系统内存量. 到这个时候, 所有IO会被阻塞</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Sep 26 07:59 /proc/sys/vm/dirty_ratio</span><br><span class="line"><span class="comment"># 指定多长时间pdflush/flush/kdmflush这些进程会唤醒一次, 然后检查是否有缓存需要清理.</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Oct 15 22:05 /proc/sys/vm/dirty_writeback_centisecs</span><br></pre></td></tr></table></figure>
<h3 id="查看内存中脏数据">查看内存中脏数据</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/vmstat | egrep <span class="string">"dirty|writeback"</span></span><br><span class="line">nr_dirty 106</span><br><span class="line">nr_writeback 0</span><br><span class="line">nr_writeback_temp 0</span><br><span class="line">nr_dirty_threshold 3934012</span><br><span class="line">nr_dirty_background_threshold 1964604</span><br></pre></td></tr></table></figure>
<h2 id="generic-block-layer">Generic Block Layer</h2>
<blockquote>
<p>通用块层的主要工作是：接收上层发出的磁盘请求，并最终发出I/O请求。该层隐藏了底层硬件块设备的特性，为块设备提供了一个通用的抽象视图。</p>
</blockquote>
<blockquote>
<p>对于VFS和具体的文件系统来说，块（Block）是基本的数据传输单元，当内核访问文件的数据时，它首先从磁盘上读取一个块。但是对于磁盘来说，扇区是最小的可寻址单元，块设备无法对比它还小的单元进行寻址和操作。由于扇区是磁盘的最小可寻址单元，所以块不能比扇区还小，只能整数倍于扇区大小，即一个块对应磁盘上的一个或多个扇区。一般来说，块大小是2的整数倍，而且由于Page
Cache层的最小单元是页（Page），所以块大小不能超过一页的</p>
<p>多情况下，数据的传输通过DMA方式</p>
</blockquote>
<p>通用块层的核心数据结构是一个称为BIO的描述符，它描述了块设备的IO操作。每个bio结构都包含一个磁盘存储区标识符（存储区中的起始扇区和扇区数目）和一个或多个描述符
与IO操作相关的内存区的段。</p>
<h2 id="device-mapper-layer15">Device Mapper Layer[^15]</h2>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-19-57.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-22-23.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="io-scheduler-layer">I/O Scheduler Layer</h2>
<p>I/O调度层的功能是管理块设备的请求队列。即接收通用块层发出的I/O请求，缓存请求并试图合并相邻的请求。并根据设置好的调度算法，回调驱动层提供的请求处理函数，以处理具体的I/O请求。</p>
<p>如果简单地以内核产生请求的次序直接将请求发给块设备的话，那么块设备性能肯定让人难以接受，因为磁盘寻址是整个计算机中最慢的操作之一。为了优化寻址操作，内核不会一旦接收到I/O请求后，就按照请求的次序发起块I/O请求。为此Linux实现了几种I/O调度算法，算法基本思想就是通过合并和排序I/O请求队列中的请求，以此大大降低所需的磁盘寻道时间，从而提高整体I/O性能。</p>
<p>常见的I/O调度算法包括Noop调度算法（No
Operation）、CFQ（完全公正排队I/O调度算法）、DeadLine（截止时间调度算法）、AS预测调度算法等。</p>
<p>在许多的开源框架如Kafka、HBase中，都通过追加写的方式来尽可能的将随机I/O转换为顺序I/O，以此来降低寻址时间和旋转延时，从而最大限度的提高IOPS。</p>
<h2 id="block-device-driver-layer">Block Device Driver Layer</h2>
<p>驱动层中的驱动程序对应具体的物理块设备。它从上层中取出I/O请求，并根据该I/O请求中指定的信息，通过向具体块设备的设备控制器发送命令的方式，来操纵设备传输数据。</p>
<blockquote>
<p>俗话说的SCSI协议栈，包括三层，一个是上层的协议驱动，指磁盘驱动，磁带驱动，如果有其他的设备，比如打印机之类的，SCSI打印机和扫描仪也有，很早的时候，这块就是驱动设备了。SCSI
Middle
层就是管SCSI指令，下发下来都是在内存里的数据结构，每个OS都不一样，但是如果发到磁盘，发到外面的交换机，必须把它弄成标准化的，因为外面有很多厂商做硬件，你不标准，就没法做了这个硬件，你不能说为每个OS都做一个硬件。这层除了翻译成SCSI指令，这边有SCSI语义，还有管真正的SCSI的处理，比如超时了怎么办这些事情，这是中间层。</p>
</blockquote>
<p>　　底下这层是HBA层，首先要有驱动，在HBA上有设备发现的这么一层库，因为传统的SCSI几十年前，那时候只有SCSI这么一种物理硬件，大家可能有人见过，很粗很笨的线缆，后来出现了FC，SAS这些，更快速的、高效的物理链路类型。SCSI协议，如果想跑在这些物理链路类型说，就需要有这么一块代码，这个网络里面，把你对端的SCSI设备发现上来，如果后端改成SAS，这块代码就会往SAS网络上发出一些广播的消息，将设备探测到，然后才生成设备符号。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-10-40-32.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-10-41-04.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-05-11-16-32.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="block-device-layer">Block Device Layer</h2>
<p>硬盘缓存功能等就在硬件内了. 比如最近我们接触的希捷高速缓存.</p>
<h1 id="块对象的io路径.">块对象的IO路径.</h1>
<h2 id="读路径">读路径</h2>
<h3 id="应用态业务程序">应用态业务程序</h3>
<h3 id="应用态程序缓存-命中则提高">应用态程序缓存, 命中则提高</h3>
<h3 id="文件系统层">文件系统层</h3>
<h3 id="内核态缓存-命中则提高-page-cache">内核态缓存, 命中则提高 page
cache?</h3>
<h3 id="通用块层">通用块层</h3>
<h3 id="内核态到块设备之间的驱动-包含缓存">内核态到块设备之间的驱动,
包含缓存?</h3>
<h3 id="分层缓存设备">分层缓存设备</h3>
<h3 id="元数据分离-通过高速硬件提高元数据读取性能">元数据分离,
通过高速硬件提高元数据读取性能</h3>
<h3 id="根据元数据指定的地址-在低速设备上查询真实速度">根据元数据指定的地址,
在低速设备上查询真实速度</h3>
<h3 id="硬盘预读能力-如果命中了提高性能">硬盘预读能力,
如果命中了提高性能</h3>
<h2 id="写路径">写路径</h2>
<h3 id="应用态业务程序-1">应用态业务程序</h3>
<h3 id="应用态程序缓存-io聚合-随机io转顺序-或缓存命中直接返回-存在一致性风险">应用态程序缓存,
IO聚合, 随机IO转顺序, 或缓存命中直接返回, 存在一致性风险</h3>
<h3 id="内核态缓-存-io聚合-或缓存命中直接返回-存在一致性风险">内核态缓
存, IO聚合, 或缓存命中直接返回, 存在一致性风险</h3>
<h3 id="内核态到块设备-驱动层面聚合">内核态到块设备, 驱动层面聚合</h3>
<h3 id="分层缓存设备-写命中的对象-则可以直接返回-免去访问更底层的">分层缓存设备,
写命中的对象, 则可以直接返回, 免去访问更底层的</h3>
<h3 id="元数据分离-如果是小io-直接落元数据分区所在的高速设备-如果是低速-则继续下传">元数据分离,
如果是小io, 直接落元数据分区所在的高速设备, 如果是低速, 则继续下传</h3>
<h3 id="硬盘随机写能力-看硬盘的算法-是否有缓存进行io聚合之类的.">硬盘随机写能力,
看硬盘的算法, 是否有缓存进行IO聚合之类的.</h3>
<h1 id="基于io路径的优化">基于IO路径的优化</h1>
<p>采用追加写</p>
<p>从文件中读一些数据时将会需要更多的时间：需要倒序扫描，直到找到所需要的内容。当然在一些简单的场景下也能够保证读操作的性能：</p>
<p>数据是被整体访问，比如HDFS</p>
<p>HDFS建立在一次写多次读的模型之上。在HDFS中就是采用了追加写并且设计为高数据吞吐量；高吞吐量必然以高延迟为代价，所以HDFS并不适用于对数据访问要求低延迟的场景；由于采用是的追加写，也并不适用于任意修改文件的场景。HDFS设计为流式访问大文件，使用大数据块并且采用流式数据访问来保证数据被整体访问，同时最小化硬盘的寻址开销，只需要一次寻址即可，这时寻址时间相比于传输时延可忽略，从而也拥有良好的读性能。HDFS不适合存储小文件，原因之一是由于NameNode内存不足问题，还有就是因为访问大量小文件需要执行大量的寻址操作，并且需要不断的从一个datanode跳到另一个datanode，这样会大大降低数据访问性能。
知道文件明确的偏移量，比如Kafka</p>
<p>LSM p</p>
<p>小文件合并
小文件合并为大文件后，首先减少了大量元数据，提高了元数据的检索和查询效率，降低了文件读写的I/O操作延时。其次将可能连续访问的小文件一同合并存储，增加了文件之间的局部性，将原本小文件间的随机访问变为了顺序访问，大大提高了性能。同时，合并存储能够有效的减少小文件存储时所产生的磁盘碎片问题，提高了磁盘的利用率。最后，合并之后小文件的访问流程也有了很大的变化，由原来许多的open操作转变为了seek操作，定位到大文件具体的位置即可</p>
<p>文件合并和元数据优化 # 直接IO[^23] &gt;
当我们以O_DIRECT标志调用open函数打开文件时，后续针对该文件的read、write操作都将以直接I/O(direct
I/O)的方式完成；对于裸设备，I/O方式也为直接I/O。 &gt; &gt;
直接I/O跳过了文件系统这一层，但块层仍发挥作用，其将内存页与磁盘扇区对应上，这时不再是建立cache到DMA映射，而是进程的buffer映射到DMA。进行直接I/O时要求读写一个扇区(512bytes)的整数倍，否则对于非整数倍的部分，将以带cache的方式进行读写。
&gt; &gt;
使用直接I/O，写磁盘少了用户态到内核态的拷贝过程，这提升了写磁盘的效率，也是直接I/O的作用所在。而对于读操作，第一次直接I/O将比带cache的方式快，但因带cache方式后续再读时将从cache中读，因而后续的读将比直接I/O快。有些数据库使用直接I/O，同时实现了自己的cache方式。</p>
<h1 id="异步aio">异步aio</h1>
<blockquote>
<p>队列深度决定了给块设备写I/O的最大并发数，对于Linux系统，默认值为128，一般情况下不建议用户修改此参数。用户可以使用cat命令查询当前块设备队列深度。
linux-ob3a:~ # cat /sys/block/sdc/queue/nr_requests</p>
</blockquote>
<h1 id="预读">预读</h1>
<blockquote>
<p>预读量的默认值为512扇区，即256KB。用户可以使用cat命令查询当前块设备预读量。</p>
</blockquote>
<blockquote>
<p>linux-ob3a:~ # cat /sys/block/sdc/queue/read_ahead_kb 512</p>
</blockquote>
<h1 id="内存参数">内存参数</h1>
<ul>
<li>$ cat /proc/sys/vm/swappiness
<ul>
<li><blockquote>
<p>vm.swappiness的值的大小对如何使用swap分区是有着很大的联系的。swappiness=0的时候表示最大限度使用物理内存，然后才是
swap空间，swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。linux的基本默认设置为60，也就是说，你的内存在使用到100-60=40%的时候，就开始出现有交换分区的使用。大家知道，内存的速度会比磁盘快很多，这样子会加大系统io，同时造的成大量页的换进换出，严重影响系统的性能，所以我们在操作系统层面，要尽可能使用内存，对该参数进行调整，一般sysctl
vm.swappiness=10。</p>
</blockquote></li>
</ul></li>
<li>$ cat /proc/sys/vm/overcommit_memory
<ul>
<li>内存分配策略</li>
<li>linux对大部分申请内存的请求都回复”yes”，以便能跑更多更大的程序。因为申请内存后，并不会马上使用内存。这种技术叫做Overcommit。当linux发现内存不足时，会发生OOM
killer(OOM=out-of-memory)。它会选择杀死一些进程(用户态进程，不是内核线程)，以便释放内存</li>
</ul></li>
<li>$ cat /proc/sys/vm/overcommit_ratio</li>
</ul>
<h1 id="前沿趋势">前沿趋势</h1>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-13-00-06-03.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2021/09/08/IO路径流向初探/IO路径流向小记_2020-12-13-00-06-42.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>[^26]</p>
<blockquote>
<p>IO出了龙潭又入虎穴，对于基于SATA/SAS
SSD的AFA来讲，SCSI层很难绕过，因为这个协议栈太过底层，SCSI指令集异常复杂，协议状态机、设备发现、错误恢复机制等哪一样都够受的，如果抛弃SCSI协议栈自己开发一个新的轻量级SCSI协议栈，那是不切实际的，你会发现倒头来不得不把那些重的代码加回来，因为SCSI体系本身的复杂性已经决定了协议栈实现上的复杂性。
然而，如果使用的是PCIE闪存卡或者2.5寸盘的话，那么就可以完全抛弃SCSI协议栈。有些PCIE闪存卡的驱动中包含了自定义的私有协议栈，其中包含了指令集、错误处理、监控等通用协议栈的大部分功能，其直接注册到块层；而NVMe协议栈迅速成了定海神针，
[^27]</p>
</blockquote>
<h1 id="调试排查29">调试排查[^29]</h1>
<h1 id="reference">Reference</h1>
<ol type="1">
<li><a href="https://tech.meituan.com/2017/05/19/about-desk-io.html" target="_blank" rel="noopener">磁盘I/O那些事
- 美团技术团队</a></li>
<li><a href="https://www.jianshu.com/p/ce43ec207ac5" target="_blank" rel="noopener">通用块层 -
简书</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/96391501" target="_blank" rel="noopener">浅谈Linux内核IO体系之磁盘IO
- 知乎</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&amp;mid=2652667287&amp;idx=1&amp;sn=0aa2f82b0f40a68314bf42da872f90d8&amp;chksm=810f3b0ab678b21c6c2a06dbb6f57cba6d55429cb20863179267e0c807146f9aa6f945dbcb64&amp;scene=27#wechat_redirect" target="_blank" rel="noopener">打通IO栈：一次编译服务器性能优化实战</a></li>
<li><a href="https://my.oschina.net/fileoptions/blog/3058792" target="_blank" rel="noopener">linux
io过程自顶向下分析 - 黑客画家的个人空间 - OSCHINA -
中文开源技术交流社区</a></li>
<li><a href="https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram" target="_blank" rel="noopener">Linux
Storage Stack Diagram - Thomas-Krenn-Wiki</a></li>
<li><a href="https://www.cnblogs.com/zhaoyl/p/5901680.html" target="_blank" rel="noopener">MMAP和DIRECT
IO区别 - aitao - 博客园</a></li>
<li><a href="https://www.zhihu.com/question/48161206" target="_blank" rel="noopener">(79 条消息) Linux
中 mmap() 函数的内存映射问题理解？ - 知乎</a><br>
</li>
<li><a href="https://segmentfault.com/a/1190000021388785" target="_blank" rel="noopener">(1)
磁盘IO瓶颈_个人文章 - SegmentFault 思否</a></li>
<li><a href="http://news.moore.ren/industry/247166.htm" target="_blank" rel="noopener">鸿蒙系统
IO栈和Linux IO栈对比分析-摩尔芯闻</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/39721251" target="_blank" rel="noopener">Linux 的IO栈 -
知乎</a></li>
<li><a href="https://blog.csdn.net/lihualoveyou/article/details/78485313" target="_blank" rel="noopener">iscsi:IO操作流程（一）_我的技术笔记-CSDN博客</a></li>
<li><a href="https://www.zhihu.com/question/56967013" target="_blank" rel="noopener">(79 条消息) NVMe
和 AHCI 到底是接口标准还是接口协议？ - 知乎</a></li>
<li><a href="https://thickforest.github.io/2015/04/904787940/" target="_blank" rel="noopener">SCSI标准分析及linux
kernel中scsi_debug模块实现详解(1)-zhenchengjin-ChinaUnix博客 |
Forest</a></li>
<li><a href="https://www.msystechnologies.com/blog/understanding-device-mapper-and-filter-driver/" target="_blank" rel="noopener">Understanding
Device Mapper and Filter Driver</a></li>
<li><a href="https://www.researchgate.net/figure/Architecture-of-Linux-Kernel-I-O-stack_fig2_317952281" target="_blank" rel="noopener">Architecture
of Linux Kernel I/O stack | Download Scientific Diagram</a></li>
<li><a href="https://new.qq.com/omn/20180127/20180127G0D4OP.html" target="_blank" rel="noopener">打造全用户态高可靠高性能的分布式存储系统-腾讯网</a></li>
<li><a href="https://longwhiteclouds.com/2016/03/06/default-io-size-change-in-linux-kernel/#:~:text=Some%20people%20may%20have%20noticed,increased%20from%20512KB%20to%201280KB." target="_blank" rel="noopener">Default
Maximum IO Size Change in Linux Kernel | Long White Virtual
Clouds</a></li>
<li><a href="https://unix.stackexchange.com/questions/529529/why-is-the-size-of-my-io-requests-being-limited-to-about-512k" target="_blank" rel="noopener">linux
- Why is the size of my IO requests being limited, to about 512K? - Unix
&amp; Linux Stack Exchange</a></li>
<li><a href="https://support.huaweicloud.com/tngg-kunpenghpcs/kunpenghpcsolution_05_0019.html" target="_blank" rel="noopener">优化磁盘IO调度方式_鲲鹏高性能计算解决方案_调优指南_IO调优_华为云</a></li>
<li><a href="https://blog.mimvp.com/article/44289.html" target="_blank" rel="noopener">Linux磁盘I/O优化：vm.dirty_ratio
- 米扑博客</a></li>
<li><a href="https://my.oschina.net/207miner/blog/2996144" target="_blank" rel="noopener">Linux机器内核参数理解(二)
- 207矿工的个人空间 - OSCHINA - 中文开源技术交流社区</a></li>
<li><a href="https://www.jianshu.com/p/2ab78406e057" target="_blank" rel="noopener">深入理解linux IO -
简书</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93803888" target="_blank" rel="noopener">3.分布式存储系统的大体架构
- 知乎</a></li>
<li>&lt;大话存储1/2&gt;</li>
<li><a href="http://www.dostor.com/article/121638064.html" target="_blank" rel="noopener">冬瓜哥：IO协议栈前沿技术研究动态
- 存储在线</a></li>
<li><a href="https://www.dellemc-solution.com/light-reading/desc.html?id=150573" target="_blank" rel="noopener">存储极客
| 浅析固态介质在存储系统中的应用方式-黑科技-轻阅读-戴尔易安信(Dell
EMC)官网</a></li>
<li><a href="https://www.slideshare.net/mryufeng/io-12278640" target="_blank" rel="noopener">了解IO协议栈</a></li>
</ol>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2021-09-27T10:10:09.999Z" itemprop="dateUpdated">2021-09-27 18:10:09</time>
</span><br>


        
        欢迎评论~
        
    </div>
    
    <footer>
        <a href="https://sean10.github.io">
            <img src="/img/avatar.jpg" alt="Sean10">
            Sean10
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IO/">IO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/存储/">存储</a></li></ul>


            
<!-- Go to www.addthis.com/dashboard to customize your tools --> 
<div class="addthis_sharing_toolbox"></div>
            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://sean10.github.io/2021/09/08/IO路径流向初探/&title=《IO路径流向初探》 — 行路中.&pic=https://sean10.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://sean10.github.io/2021/09/08/IO路径流向初探/&title=《IO路径流向初探》 — 行路中.&source=笔记 随笔" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://sean10.github.io/2021/09/08/IO路径流向初探/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《IO路径流向初探》 — 行路中.&url=https://sean10.github.io/2021/09/08/IO路径流向初探/&via=https://sean10.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://sean10.github.io/2021/09/08/IO路径流向初探/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2021/09/17/vscode之markless二次开发/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">[no title]</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2021/08/13/python日志模块初探/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">python日志模块初探</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "yNexbxJmshSneppnaoo3Bd6Y-gzGzoHsz",
            appKey: "FyxT8MxDPHbu8mQSapgjEMPC",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>




        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Sean10 &copy; 2015 - 2022</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://sean10.github.io/2021/09/08/IO路径流向初探/&title=《IO路径流向初探》 — 行路中.&pic=https://sean10.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://sean10.github.io/2021/09/08/IO路径流向初探/&title=《IO路径流向初探》 — 行路中.&source=笔记 随笔" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://sean10.github.io/2021/09/08/IO路径流向初探/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《IO路径流向初探》 — 行路中.&url=https://sean10.github.io/2021/09/08/IO路径流向初探/&via=https://sean10.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://sean10.github.io/2021/09/08/IO路径流向初探/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://sean10.github.io/2021/09/08/IO路径流向初探/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<!-- Go to www.addthis.com/dashboard to customize your tools --> 
<script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-57108c0b91bea817"></script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->





</body>
</html>
